\chapter{Probleme und Lösungsansätze}
% Noch nicht auf spezielle technische Lösungen eingehen!

\section{Authentizität der Records}
Wie in \ref{} beschrieben baut sich das DNS aus verschiedenen Zonen auf, die wiederum aus Einträgen (Resource Records; RR) bestehen. Obwohl das Format und der Aufbau der beschreibenden Zonen-Files klar spezifiziert ist, wurde in der urprünglichen DNS-Spezifikation keine Möglichkeit zur Prüfung der Authentizität festgeschrieben. Somit ist es weder für die Server-Software noch für die empfangenen Clients möglich die Herkunft der Einträge zu prüfen. Dieser Umstand stellt eine der zentralen Schwachstellen der aktuellen DNS Infrastruktur dar und ist Grundlage für verschiedenste Anfriffe wie DNS Spoofing und DNS Cache Poisoning.

Zur Lösung dieses Problems wurde schon früh eine Erweiterung des Standard um spezielle RRs vorgeschlagen. Mit diesen werden kryptografische Signaturen zu verschiedenen Einträgen, auf Anfrage, mitgeliefert. Dadurch wird es möglich die Integrität und Authentizität der empfangenen Einträge sicherzustellen. Werden die Zonendateien offline signiert, besteht sogar die Möglichkeit Server-Konfigurationen vor ungewollter Veränderung zu schützen. Dies kann durch das verwenden von asymmetrischer Kryptografie ermöglicht werden. Wobei sich, wie bei allen Signaturverfahren, noch die Frage des Vetrauens stellt. Die notwendige Vertrauensstellung kann dabei auf verschiedenste Wege hergestellt werden. Die gängigsten sind "Chain-of-trust", "Web-of-trust", "Shared Key" und "trust-on-first-use".

In manchen Spezielfällen kann die Integrität der beabsichtigten Anfrage leider trotz Signatur nicht garantiert werden. Einer dieser Angriffe basiert auf die Schwächen mancher Cypher-Suits mit unzureichend sicheren Hash-Algorithmen oder zu kurzen Schlüsseln (siehe Shattered). Eine andere Möglichkeit bietet das sogenannte "BitSquatting". Bei diesem Angriff werden zufällige Fehler im Speicher von Geräten ohne Fehlerresistenten Speichermodulen ausgenützt. Da es dadurch zu flaschen Anfragen kommt, gibt es auch keine Möglichkeit sich auf Protokoll- bzw. System-Ebene zu schützen. Die einzige effektive Lösung stellt der Einsatz von ECC-RAM Hardware dar.   

% Lösung für Authentizität der Records => Signieren der Records (offline/online; DNSSec, DNSCurve, DoT/DoH; Chain-Of-Trust)
% BitSquatting?! Signieren schützt nicht, da die Anfrage schon früh gegen das falsche System gestellt wurd.


\section{Authentizität der Endstelle}
Die in den Beginnen des Webs mit HTTP ist auf bei der Konzeptionierung der DNS Protokolls keine Rücksicht auf potenziell feindseelige Server rücksicht genommen worden. Da DNS bewusst auf jede Form von Authentifizierung verzichtet ist auch ein Prüfen der Identität der jeweiligen Gegenstelle nicht vorgesehen. Dies birgt jedoch eine hohe Anfälligkeit auf Man-in-the-Middle Attacken. Ein Angreifer dem es gelingt sich aus sicht des Netzwerks zwischen eine der Komponenten im Abfrageablauf zu positionieren hat komplette Kontrolle über den Informationsfluss zwischen den betroffenen Geräten. Sollte sich der Angreifer zwsichen Endgerät und Recursive DNS Server befinden, kann jede DNS-Interaktion nach belieben manimuliert werden. Solle es dem Angreifer gelingen sich vor einem Authoritativem DNS-Server zu stellen, können alle Antworten an die von diesem Server bereitgestellten Domänen manimuliert werden. Die verteilte Natur von DNS sorgt zusätzlich dafür, dass, Einträge für lange Zeit verändert werden können, ohne dass es eine einfache Form der remediation gibt.

Abhilfe für dieses Problem schafft einerseits die schon besprochene kryptographische Signierung der Einträge, da so selbst bei einem Eingriff keine unbemerkte Modifikation des Inhalts möglich ist. Dieser theoretischer Schutz scheitert jedoch an der praktischen Umsetzung, da es einen Fallback-Mechanismus ausschließen müsste, da sonst der Angreifer einfach die Signature aus dem Antwort-Paket entfernen könnte.

Die verbreitetste Lösung für dieses Problem ist wohl ein auf asymmertischer Kryptografie besierendes Authentifizierungsverfahren. Am einfachsten wird dafür ein nach X.509 Standard erstelltes Zertifikat mit passendem Schlüsselpaar verwendet. Die Authentizität der Endstelle wird Anhand eines Handshakes sichergestellt, indem der Server durch die Entschlüsselung eines mit dem im Zertifikat genannten Geheimtexts beweißt, dass er im Besitz des passenden privaten Schlüssels ist. Die Validität des Zertifikats und damit des öffentlichen Schüssels wir über eine Chain-of-trust sichergestellt. Dabei muss der Client einer Root Certificate Authority (CA) schon vor dem Verbindungsaufbau zum Server vertauen. Ist das Server-Zertifikat nun von eine Vertauenswürdigen CA signiert, wurde es von dieser geprüft und ist damit transitiv vertauenswürdig.

% Lösung für Authentizität der Endstelle => Verbindungsaufbau nur nach authentifizierung des Servers (über X509 Certs)

\section{ Vertraulichkeit der Übertragung}
% Lösung für Vertraulichkeit der Übertragung => Verschlüsseln der Übertragung (TLS, DNSCurve)

Die nachhaltige Lösung ist, wie damals auch bei HTTP, der Einsatz einer geeigneten Transportverschlüsselung. Auf welcher Netzwerkebene diese Stattfindet und wie die eigentliche validierung der Identitäten durchgeführt ist dafür grundsätzlich egal. Der Einsatz von etablierten Technologien wie IPSec oder TLS liegt jedoch nahe.


\section{Vertraulichkeit der Anfragen}
% Lösung für Vertraulichkeit der Anfragen => Mit DNS nicht möglich. Blockchain basierte ansätze möglich

\section{Nutzung als DoS-Amplifier}
% Lösung für Nutzung als DoS-Amplifier => Protokolle mit Handshake



